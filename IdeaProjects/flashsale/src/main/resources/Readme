解决超卖问题：
秒杀：首先判断库存够不够，然后判断是否是重复秒杀，然后进行秒杀逻辑（更新数据库）
当库存为1时，两个人同时秒杀，库存为负，数据库会对这条数据加锁，不会出现两个线程同时操作一条记录
两个用户同时更新数据库：where goods_id = #{goodsId} and stock_count > 0")
==========================================================================================
一个用户同时发出两个请求，同时减库存，同时下订单，一个用户秒杀到两个商品
订单表/秒杀订单表
一个用户秒杀到两件商品：miaosha_order user_id good_id数据库中唯一键索引，防止用户插入到重复的记录


商品列表页
想要查找商品信息和秒杀信息（两张表）
把两张表的数据重新放在新的GoodsVO extends Goods

商品详情页
一般id不使用自增，容易被遍历
秒杀还没开始：做倒计时处理，不能点击秒杀按钮
秒杀正式开始：点击秒杀，判断是否还有库存，如果有，则生成订单

订单详情页
前后端交互：
后端：model.addAttribute("user", user);
      model.addAttribute("goods", goods);
前端：
        <td>商品名称</td>
        <td th:text="${goods.goodsName}" colspan="3"></td>


页面级优化：
并发的瓶颈就是数据库
1. 减少对数据库的访问：页面级缓存（力度最大） + url缓存 + 对象级缓存
2. 页面静态化(前后端分离[jsp thymeleaf ])：浏览器把html缓存到本地，页面数据不需要重复下载，只需要去请求动态的数据
3. CDN优化


页面级缓存：访问一个页面，不是直接渲染，而是去缓存中找，找到了直接返回给客户端，没找到就手动渲染模板，渲染之后返回给客户端，并且保存在Redis中
有效期不能太久（60s）：数据实时性不好
商品列表页使用了页面级缓存（适用于变化不大的页面）
redisService.set(GoodsKey.getGoodsList, "", html);//保存在redis中
String html = redisService.get(GoodsKey.getGoodsList, "", String.class);
商品详情页：url级缓存（不同商品跳转到不同的页面）

对象级缓存：只有不变，永久有效
获取对象时，先去缓存中找，如果没找到，去数据库中找，取到之后，在放到缓存中

修改用户密码：先更新数据库，再更新缓存（数据库和缓存的一致性）
先删掉缓存，从数据库把旧的数据加载到缓存，此时再去更新数据库，两者之间的数据就不一致了


QPS: 1267 --> 2884


页面静态化：动态数据从接口在服务端获取
本来去取缓存，return html
现在直接去请求一个html return


CDN:总是访问离得最近的节点
页面静态化（把页面缓存到浏览器）--> 页面缓存 -->对象缓存

接口优化：
1. Redis预减库存，减少对数据库的访问
2. 内存标记，减少对reids的访问
3. 收到秒杀请求，放入队列中，异步请求


1.系统初始化，把商品库存数量加载到redis
2.收到请求，redis预减库存，库存不足，直接返回
3.有库存，请求入队，返回排队中
4.请求出队，生成订单，减少库存
5.客户端轮询，是否秒杀成功








